<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shadow</title>
</head>
<body>
   <style>
#caster {
  height: 400.5px;
  width: 400.5px;
  border: hsl(0, 0%, 0%) 5px outset;
  top: 50px;
  transform: translate(50%, 0);
  position: absolute;
  top: 15%;
  left: 30px;
}
.canvas {
  height: 400.5px;
  width: 400.5px;
  border: hsl(0, 0%, 0%) 5px outset;
  top: 50px;
  transform: translate(50%, 0);
  position: absolute;
}
#stage {
  top: 15%;
  left: 460px;
}
.cons {
  font: 1.4em monospace;
  align-items: center;
  position: absolute;
}
#castCons {
  top: 50px;
  left: 300px;
}
#central {
  top: 500px;
  left: 540px;
}
#stageCons {
  top: 50px;
  left: 800px;}
  </style>
<canvas class="canvas" id="caster"; height = 400.5 ; width = 400.5 ; onmousemove="bingo(event)" >lmao wrnog browsr</canvas>
<canvas class="canvas" id="stage"; height = 400.5 ; width = 400.5 ; onmousemove="bingo(event)">lmao wrnog browsr</canvas>

<div class="cons"; id="castCons">me when </div>
<div class="cons"; id="central">websitr dosnt laod corctly</div>
<div class="cons"; id="stageCons">mw when the </div>

<script>class position {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
}
const roofColor= "#AA79B9";
const floorColor= "#011638";
const renderdist = 250
const pixlRate = 1
const distRate= 3
const addedView = 15
const caster = document.getElementById("caster");
const ctx = caster.getContext("2d");
const castCon = document.getElementById("castCons");
const central = document.getElementById("central");
const stageCon = document.getElementById("stageCons");
const stage = document.getElementById("stage");
const sctx = stage.getContext("2d");
var mouseX = 180
var mouseY = 200
var rays = [];
class ray {
  constructor(id, value, length) {
    this.id = id
    this.value = value
    this.length = Math.abs(length-renderdist);
    this.rgb = "rgba(" + this.value + ")"
  }
}
class theSun {
  constructor(pos, size, view, color,speed) {
    this.pos = pos
    this.size = size;
    this.view = view
    this.color = color
    this.speed = speed
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, this.size, 0 * Math.PI, 2 * Math
      .PI);
    ctx.fill();
    ctx.stroke();
  }
}
var sunny = new theSun(new position(200, 50), 25, 0,
  "rgba(255, 58, 60, .5)",15);
var frames = 0

function gameLoad() {
  frames += 1
  ctx.clearRect(0, 0, caster.width, caster.height)
  //THIS IS THE DRAW ZONE; things placed here will have rays casted apon them
  ctx.fillStyle = "red"
  ctx.fillRect(120, 120, 30, 80)
  ctx.fillStyle = "green"
  ctx.fillRect(160, 160, 30, 80)
  ctx.fillStyle = "blue"
  ctx.fillRect(200, 200, 30, 80)
  central.innerHTML = frames;

  /*here we need to track the wmount of rays made automaticly becasue... 
  well because fuck you thats why we willl to this wuth the following ray Ammount varubl*/

  var rayAmount =0 //(Math.abs((sunny.size * -1)-addedView)+ sunny.size+addedView)/pixlRate
  for(let i = (sunny.size * -1)-addedView; i < sunny.size+addedView; i += pixlRate) {
    rayAmount++
    let directX = Xratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY);
    let directY = Yratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY);
    let leftX = Yratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY) * -1;
    let leftY = Xratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY);
    let it = 0
    while(renderdist >= it) {
      let startX = sunny.pos.x + (i * leftX);
      let startY = sunny.pos.y + (i * leftY);
      var imgdata = ctx.getImageData(startX + (it * directX), startY +(it * directY), 1, 1, { colorSpace: "srgb" }).data.toString()
      
      ctx.fillStyle = "black"
      //to later be used as a post-scan loaded debuging tool as to not interact with the data colection
    // ctx.fillRect(startX + (it * directX), startY + (it * directY),1, 1, )
      it += distRate
      //done
      if(imgdata != "0,0,0,0") {
        if(imgdata != "0,0,0,255") { break }}
    }
    rays.length = Math.abs((sunny.size * -1)-addedView) + sunny.size+addedView / pixlRate;
    //after the while loop ends iether through break or of length it gets sorted here
    rays.shift()
    rays.push(new ray(i, imgdata, it))
    /*FOR LOOP*/}
  sunny.draw()
  ctx.fillStyle = "black"
  ctx.beginPath();
ctx.moveTo(sunny.pos.x, sunny.pos.y);
ctx.lineTo(mouseX, mouseY);
ctx.stroke();
castCon.innerHTML =  rays.length+" and it should be "+rayAmount
  //??
  central.innerHTML = " x = " + Math.floor(Xratio(sunny.pos.x, sunny
      .pos.y, mouseX, mouseY * 100)) + 
    " y = " + Math.floor(Yratio(
      sunny.pos.x, sunny.pos.y, mouseX, mouseY) * 100) +
    " total change = " + (Math.abs(Xratio(sunny.pos.x, sunny.pos.y,
      mouseX, mouseY)) + Math.abs(Yratio(sunny.pos.x, sunny.pos.y,
      mouseX, mouseY)));
  //what the f#*@ is going on up thier??
}
//jesus christ almighty 
function stageLoad() {
  sctx.clearRect(0, 0, caster.width, caster.height)
  //asdfghjkl dont ask, noooooo fukn clu wjats going on here
  for(let i = 0; i < rays.length; i++) {
   let shader = "rgba(0,0,0,"+Math.abs((map(rays[i].length,0,renderdist,0,120)/100)-1)+")"
   let curntXStart = i * (400 / rays.length);
   let curnyXEnd = (400 / rays.length)+1;
   //draw the item
    sctx.fillStyle = rays[i].rgb 
    sctx.fillRect(curntXStart, ( rays[i].length/2)-10, curnyXEnd, (rays[i].length+(rays[i].length/2))+25)
    //draw the floor
    sctx.fillStyle = floorColor
    sctx.fillRect(curntXStart, (( rays[i].length/2)-10)+(rays[i].length+(rays[i].length/2))+25, curnyXEnd, 400)
    //shade the item
    sctx.fillStyle = shader
    sctx.fillRect(curntXStart, ( rays[i].length/2)-10, curnyXEnd, (rays[i].length+(rays[i].length/2))+25)
stageCon.innerHTML= shader
}
}
// ***************************************************************
document.onkeydown = keypress;

function keypress(event) {
  central.innerHTML = event.code
  switch(event.code) {
    case "Space":
      setInterval(gameLoad, 1000 / 25);
      setInterval(stageLoad, 1000 / 25);
      break;
    case "ArrowRight":
      sunny.pos.x += sunny.speed
      break;
    case "ArrowUp":
      sunny.pos.y -= sunny.speed
      break;
    case "ArrowLeft":
      sunny.pos.x -= sunny.speed
      break;
    case "ArrowDown":
      sunny.pos.y += sunny.speed
      break;
    default:
      break;
  }
}
var mouseFoc = null;

function bingo(Event) {
   mouseX = Event.clientX - Event.currentTarget.offsetLeft - 200;
  mouseY = Event.clientY - Event.currentTarget.offsetTop;
  if(event.clientX <= 650) {
    mouseFoc = "caster"
  } else {
    mouseFoc = "stage"
  }
}
//********************UTILITY FUNCTIONS********************
function Xratio(x1, y1, x2, y2) {
  return (x2 - x1) / getDistance(x1, y1, x2, y2)}

function Yratio(x1, y1, x2, y2) {
  return (y2 - y1) / getDistance(x1, y1, x2, y2)}

function getDistance(x1, y1, x2, y2) {
  let y = x2 - x1;
  let x = y2 - y1;
  return Math.sqrt(x * x + y * y);}
  function map( x,inmin,inmax,outmin,outmax) {
  return (x - inmin) * (outmax - outmin) / (inmax - inmin) + outmin;}

  </script>
</body>
</html>