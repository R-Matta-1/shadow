<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shadow</title>
</head>
<body>
   <style>
#caster {
  height: 400.5px;
  width: 400.5px;
  border: hsl(0, 0%, 0%) 5px outset;
  top: 50px;
  transform: translate(50%, 0);
  position: absolute;
  top: 15%;
  left: 30px;
}
.canvas {
  height: 400.5px;
  width: 400.5px;
  border: hsl(0, 0%, 0%) 5px outset;
  top: 50px;
  transform: translate(50%, 0);
  position: absolute;
}
#stage {
  top: 15%;
  left: 460px;
}
.cons {
  font: 1.4em monospace;
  align-items: center;
  position: absolute;
}
#castCons {
  top: 50px;
  left: 200px;
}
#central {
  top: 500px;
  left: 540px;
}
#stageCons {
  top: 10px;
  left: 800px;}
  </style>
<canvas class="canvas" id="caster"; height = 400.5 ; width = 400.5 ; onmousemove="bingo(event)" >stop using operaGX</canvas>
<canvas class="canvas" id="stage"; height = 400.5 ; width = 400.5 ; onmousemove="bingo(event)">stop using operaGX</canvas>

<div class="cons"; id="castCons">me when </div>
<div class="cons"; id="central">websitr dosnt laod corctly</div>
<div class="cons"; id="stageCons">mw when the </div>
<label id="addedVLable" for="addedV">FOV
<input type="range" name="addedV" id="addedV" min="-20" max="50" value ="10"></label>

<label id="shadeBuffLable" for="shadeB">shadeBuff
  <input type="range" name="shadeB" id="shadeB" min="0" max="100" step="1" value ="86"></label>

  <button onclick="bellowthis()">debug</button>
<script>
//laptp
function bellowthis() {
   if(debugMode==true){debugMode=false}else{debugMode=true}
}
class position {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
}
var debugMode = false
const roofColor= "#AA79B9";
const floorColor= "#011638";
const renderdist = 250
var shadeBuff = .5
const pixlRate = 1
const distRez= 3
var addedView = 5
const caster = document.getElementById("caster");
const ctx = caster.getContext("2d");
const castCon = document.getElementById("castCons");
const central = document.getElementById("central");
const stageCon = document.getElementById("stageCons");
const stage = document.getElementById("stage");
const sctx = stage.getContext("2d");
var mouseX = 180
var mouseY = 200
var rays = [];
class ray {
  constructor(id, value, length) {
    this.id = id
    this.value = value
    this.length = Math.abs(length-renderdist);
    this.rgb = "rgba(" + this.value + ")"
  }
}
class theSun {
  constructor(pos, size, view, color,speed) {
    this.pos = pos
    this.size = size;
    this.view = view
    this.color = color
    this.speed = speed
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, this.size, 0 * Math.PI, 2 * Math
      .PI);
    ctx.fill();
    ctx.stroke();
  }
}
var sunny = new theSun(new position(200, 50), 25, 0,
  "rgba(255, 58, 60, .90)",15);
var frames = 0

function gameLoad() {
  
  frames += 1
  ctx.clearRect(0, 0, caster.width, caster.height)
  //THIS IS THE DRAW ZONE; things placed here will have rays casted apon them

  borderRect(ctx,0,100,50,400,10,"#789","#123")
  borderRect(ctx,120,120,30,80,10,"red","#500")
  borderRect(ctx,170,170,30,80,10,"green","#050")
  borderRect(ctx,220,220,30,80,10,"blue","#005")

  /*here we need to track the wmount of rays made automaticly becasue... 
  well because fuck you thats why we willl to this wuth the following ray Ammount varubl*/

  var rayAmount =0 //(Math.abs((sunny.size * -1)-addedView)+ sunny.size+addedView)/pixlRate
  for(let i = (sunny.size * -1)-addedView; i < sunny.size+addedView; i += pixlRate) {
    rayAmount++
    let directX = Xratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY);
    let directY = Yratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY);
    let leftX = Yratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY) * -1;
    let leftY = Xratio(sunny.pos.x, sunny.pos.y, mouseX, mouseY);
    let it = 0
    while(renderdist >= it) {
      let startX = sunny.pos.x + (i * leftX);
      let startY = sunny.pos.y + (i * leftY);
      var imgdata = ctx.getImageData(startX + (it * directX), startY +(it * directY), 1, 1, { colorSpace: "srgb" }).data.toString()
      
      ctx.fillStyle = "black"
      //to later be used as a post-scan loaded debuging tool as to not interact with the data colection
     if(debugMode == true){ctx.fillRect(startX + (it * directX), startY + (it * directY),1, 1, )}
      it += distRez
      //done
      if(imgdata != "0,0,0,0") { break }
    }
    rays.length = (Math.abs((sunny.size * -1)-addedView) + sunny.size+addedView) / pixlRate;
    //after the while loop ends iether through break or of length it gets sorted here
    rays.shift()
    rays.push(new ray(i, imgdata, it))
    //could also make it a get dist
    /*FOR LOOP*/}
  sunny.draw()
  ctx.fillStyle = "black"
  ctx.beginPath();
ctx.moveTo(sunny.pos.x, sunny.pos.y);
ctx.lineTo(mouseX, mouseY);
ctx.stroke();
castCon.innerHTML =  rays.length+" and it should be "+rayAmount+" and "+ (1 * (400 / rays.length))  +"isthe first 2/400"
  //??
  central.innerHTML = " x = " + Math.floor(Xratio(sunny.pos.x, sunny
      .pos.y, mouseX, mouseY * 100)) + 
    " y = " + Math.floor(Yratio(
      sunny.pos.x, sunny.pos.y, mouseX, mouseY) * 100) + 
    " total change = " + (Math.abs(Xratio(sunny.pos.x, sunny.pos.y,
      mouseX, mouseY)) + Math.abs(Yratio(sunny.pos.x, sunny.pos.y,
      mouseX, mouseY)));
  //what the f#*@ is going on up thier??
}

function stageLoad() {
  sctx.clearRect(0, 0, caster.width, caster.height)
  //asdfghjkl dont ask, noooooo fukn clu wjats going on here
    //draw the floor
    sctx.fillStyle = floorColor
    sctx.fillRect(0,  150, 400, 250)
    sctx.fillStyle = roofColor
    sctx.fillRect(0,  0, 400, 150)
  for(let i = 0; i < rays.length; i++) {
   let shader = "rgba(0,0,0,"+(Math.abs((rays[i].length/renderdist)-1)*shadeBuff)+")"
   let curntXStart = i * (400 / rays.length);
   let curnyXEnd = (400 / rays.length)+1;
   let startY = Math.abs((rays[i].length/2)-150)
  
     
   //draw the item
    sctx.fillStyle = rays[i].rgb 
    sctx.fillRect(curntXStart,  startY, curnyXEnd, (rays[i].length+(rays[i].length/2)))

    //shade the item
    sctx.fillStyle = shader
    sctx.fillRect(curntXStart,  startY, curnyXEnd, (rays[i].length+(rays[i].length/2)))
    stageCon.innerHTML= shadeBuff

}
statUpdate()
}
function statUpdate() {
  addedView = parseInt(document.getElementById("addedV").value)
  shadeBuff =  parseInt(document.getElementById("shadeB").value)/100
}
function borderRect(Fctx,x,y,x2,y2,border,color,borderC) {
  let borderSize=0
  if(x2<=y2){borderSize = x2/border}else{borderSize = y2/border}
  Fctx.fillStyle = color
  Fctx.fillRect(x,y,x2,y2)
  Fctx.fillStyle = borderC
  Fctx.fillRect(x,y, borderSize,  borderSize)
  Fctx.fillRect(x+x2-(borderSize),y,borderSize,  borderSize)
  Fctx.fillRect(x,y+y2-(borderSize),  borderSize,  borderSize)
  Fctx.fillRect(x+x2-(borderSize),y+y2-(borderSize),borderSize,borderSize)
}

// ***************************************************************
document.onkeydown = keypress;

function keypress(event) {
  central.innerHTML = event.code
  switch(event.key) {
    case " "://space
  
      setInterval(gameLoad, 1000 / 25);
      setInterval(stageLoad, 1000 / 25);
      break;
    case "d":
      sunny.pos.x += sunny.speed
      break;
    case "w":
      sunny.pos.y -= sunny.speed
      break;
    case "a":
      sunny.pos.x -= sunny.speed
      break;
    case "s":
      sunny.pos.y += sunny.speed
      break;
    default:
      break;
  }
}
var mouseFoc = null;

function bingo(Event) {
   mouseX = Event.clientX - Event.currentTarget.offsetLeft - 200;
  mouseY = Event.clientY - Event.currentTarget.offsetTop;
  if(event.clientX <= 650) {
    mouseFoc = "caster"
  } else {
    mouseFoc = "stage"
  }
}
//********************UTILITY FUNCTIONS********************
function Xratio(x1, y1, x2, y2) {
  return (x2 - x1) / getDistance(x1, y1, x2, y2)}

function Yratio(x1, y1, x2, y2) {
  return (y2 - y1) / getDistance(x1, y1, x2, y2)}

function getDistance(x1, y1, x2, y2) {
  let y = x2 - x1;
  let x = y2 - y1;
  return Math.sqrt(x * x + y * y);}


  </script>
</body>
</html>